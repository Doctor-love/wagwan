#!/usr/bin/env python

'''wagwan - Generates a friendly status report from op5 Monitor'''

prog = 'wagwan'
version = '0.1'
description = __doc__
author = 'Joel Rangsmo <joel@rangsmo.se>'
license = 'GPLv2'

logger = ''

# Imports required Python modules
try:
    import argparse
    import logging
    import logging.handlers
    import requests
#    import datetime
    import random
    import json

except ImportError as excp:
    print 'Error - could not import all required Python modules: "%s"' % excp
    exit(3)


# Class used for communicating with the op5 Monitor REST API
class MonitorApi(object):
    '''Object used for communicating with the op5 Monitor REST API'''

    class QueryError(Exception):
        '''Exceptions produced for failed logins, timeouts and similar'''

        def __init__(self, msg):
            self.msg = msg

        def __str__(self):
            return self.msg

    def __init__(self, username, password, server, verify):
        self.username = username
        self.password = password
        self.server = server
        self.verify = verify

        logger.debug(
            'Created API communication object with ' +
            'username "%s" for op5 Monitor server "%s". '
            % (self.username, self.server) +
            'Certificate verification enabled: %s' % str(self.verify))

    # Function to get data from Monitor's API
    def get_data(self, path, options):
        '''Function to get data from Monitor\'s API.
        Expects two arguments - a API path and URL options in a dict'''

        logger.debug(
            'Getting data from path "%s" with URL options "%s"'
            % (path, options))

        try:
            query = requests.get(
                'https://%s/api/%s'
                % (self.server, path), verify=self.verify, timeout=35,
                auth=(self.username, self.password), params=options)

        # Exception handling (timeouts, SSL issues, etc)
        except requests.exceptions.Timeout:
            raise self.QueryError(
                'Connection to server "%s" timed out'
                % self.server)

        except requests.exceptions.SSLError:
            raise self.QueryError(
                'Failed to verify certificate for server "%s"'
                % self.server)

        except requests.exceptions.ConnectionError:
            raise self.QueryError(
                'Failed to connect to server "%s"'
                % self.server)

        except requests.exceptions.RequestException as unknown:
            raise self.QueryError(
                'Unknown connection exception: "%s"' % unknown)

        logger.debug(
            'Server response data: status code: "%s", text: "%s"'
            % (query.status_code, query.text))

        return query

    # Function to check status codes from Monitor's API responses
    def check_status_code(self, response):
        '''Function to check status codes from Monitor\'s API responses.
        Expects one argument - a object generated by requests,
        including status code and response data'''

        if response.status_code == 200:
            logger.debug('Status code in server response was OK')

            return True

        elif response.status_code == 401:
            logger.debug(
                'Server responded with status code 401 - response text: "%s"'
                % response.text)

            raise self.QueryError(
                'Invalid username, password or insuficient privileges ' +
                'for user "%s" on server "%s"'
                % (self.username, self.server))

        elif response.status_code == 404:
            logger.debug(
                'Server responded with status code 404 - response text: "%s"'
                % response.text)

            raise self.QueryError(
                'Server responded with file not found - are you ' +
                'sure the server is running op5 Monitor 6.3 or later?')

        else:
            logger.debug(
                'Server responded with status code %i - response text: "%s"'
                % (response.status_code, response.text))

            raise self.QueryError(
                'Server responded with file not found - are you ' +
                'sure the server is running op5 Monitor 6.3 or later?')

        return False

    # Function to decode JSON data in response to Python list
    def decode_response(self, response):
        '''Function to decode JSON data in response to Python list.
        Expects one argument - a JSON blob, hopefully containing data'''

        logger.debug('Decoding JSON response data')

        try:
            response = json.loads(response)

        except ValueError:
            raise self.QueryError(
                'Failed to decode data in response from filter query')

        logger.debug('Response was decoded successfully')

        return response

    # Function to query list filters
    def query_filter(self, lfilter, columns):
        '''Function to query list filters.
        Expects two arguments - a filter query and a list of columns'''

        logger.debug(
            'Querying filter "%s" for columns "%s"' % (lfilter, columns))

        # Joining columns to expected format and building URL options
        if not isinstance(columns, list):
            raise self.QueryError('Data columns were not provided as list')

        if not columns:
            raise self.QueryError('No data columns were provided in query')

        options = {
            'query': lfilter, 'columns': ','.join(columns), 'format': 'json'}

        # Performs the filter query and validates the response
        query = self.get_data('filter/query', options)

        if self.check_status_code(query):
            return self.decode_response(query.text)

        else:
            return False


# Parses command line arguments
def arg_parser(prog, version, description, author, license):
    '''Parses command line arguments.
    The function takes five arguments - app name, decription, version, author
    and license. These will be used in the generation of the help text'''

    parser = argparse.ArgumentParser(
        description=description,
        epilog='Developed by %s - Licensed under %s' % (author, license),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument(
        '-s', '--server',
        help='Specifies op5 Monitor server host',
        default='127.0.0.1')

    parser.add_argument(
        '-u', '--username',
        help='Specifies username for op5 Monitor connection',
        required=True)

    parser.add_argument(
        '-p', '--password',
        help='Specifies password op5 Monitor connection',
        required=True)

    parser.add_argument(
        '-i', '--insecure', dest='verify',
        help='Disable certificate verification (not recommended)',
        action='store_false', default=True)

    parser.add_argument(
        '-e', '--exclude-host', dest='exc_host',
        help='Exclude host from report (can be used multiple times)',
        action='append')

    parser.add_argument(
        '-E', '--exclude-hostgroup', dest='exc_host_g',
        help='Exclude host group from report (can be used multiple times)',
        action='append')

    parser.add_argument(
        '-b', '--boring',
        help='Enable enterprise friendly greeting messages',
        action='store_true', default=False)

    parser.add_argument(
        '-l', '--logging',
        help='Set application logging destination',
        choices=('stream', 'syslog', 'none'), default='stream')

    parser.add_argument(
        '-V', '--verbose',
        help='Enable verbose logging',
        action='store_true', default=False)

    parser.add_argument(
        '-v', '--version', help='Display application version',
        action='version', version=version)

    args = parser.parse_args()

    return args


# Configures application logging
def log_init(prog, destination, verbose):
    '''Configures application logging.
    The function takes three arguments - application name, logging destination
    (Syslog, stream or none) and if debug output should be enabled'''

    logger = logging.getLogger(prog)
    formatter = logging.Formatter(
        '%s: %%(levelname)s - %%(message)s' % prog)

    if verbose:
        logger.setLevel(logging.DEBUG)

    else:
        logger.setLevel(logging.INFO)

    if destination == 'stream':
        loghandler = logging.StreamHandler()

    elif destination == 'syslog':
        loghandler = logging.handlers.SysLogHandler(address='/dev/log')

    elif destination == 'none':
        loghandler = logging.NullHandler()

    loghandler.setFormatter(formatter)
    logger.addHandler(loghandler)

    logger.debug(
        'Logging has been initiade for "%s", destined for %s' %
        (prog, destination))

    return logger


# Generates random greeting and good bye message
def gen_greeting(boring):
    '''Generates random greeting and good bye message.
    The function takes one argument - if it is True,
    a enterprise friendly greeting will be provided.
    Returns a dict with a greeting and good bye message'''

    # If the boring option is enabled, we will give them what they expect...
    if boring:
        logger.debug('Enterprise ready greeting has been selected')

        return {'hi': 'Monitoring status report:', 'bye': ''}

    greetings = [
        ['Ohoy there matey!', 'Take care now, you old pirate'],
        ['Hey man - what\'s up?', 'Cya around, mate'],
        ['Moshi moshi!', 'Soreja mata.'],
        ['Time appropriate greetings!', 'Bye bye!'],
        ['Oh... I didn\'t see you there!', 'Until next time!'],
        ['Howdy, partner.', 'Keep on ridin\''],
        ['BEGIN TRANSMISSION:', 'END TRANSMISSION'],
        ['Wagwan, rudeboy?', 'Peace, love and Inity!'],
        ['I had the strangest dream - there was this huge dragon and... ' +
         'oh, well.. never mind.', 'Bye now.']]

    greeting = greetings[random.randrange(0, len(greetings))]
    logger.debug('Randomized greeting: "%s"' % str(greeting))

    return {'hi': greeting[0], 'bye': greeting[1]}


# Generates exclude filter for hosts and host groups
def gen_exclude_filter(hosts, groups):
    '''Generates exclude filter for hosts and host groups.
    The function takes two arguments - a list containing hosts
    and a list containing host groups to exclude.
    Returns a dict with negate strings for host and services'''

    filter_hosts = []
    filter_services = []

    if hosts:
        logger.debug(
            'Generating exclude filters for host(s)')

        for host in hosts:
            filter_hosts.append(
                'name ~~ "%s"' % host)

            filter_services.append(
                'host.name ~~ "%s"' % host)

    if groups:
        logger.debug(
            'Generating exclude filters for host group(s)')

        for group in groups:
            filter_hosts.append(
                'groups >= "%s"' % group)

            filter_services.append(
                'host.groups >= "%s"' % group)

    if filter_hosts:
        filter_hosts = (
            ' and not (' + ' or '.join(filter_hosts) + ')')

        logger.debug(
            'Generated hosts exclusion filter: "%s"'
            % filter_hosts)

    else:
        logger.debug(
            'Generating no exclusion filter for hosts')

        filter_hosts = ''

    if filter_services:
        filter_services = (
            ' and not (' + ' or '.join(filter_services) + ')')

        logger.debug(
            'Generated services exclusion filter: "%s"'
            % filter_services)

    else:
        logger.debug(
            'Generating no exclusion filter for services')

        filter_services = ''

    return {'hosts': filter_hosts, 'services': filter_services}


# Generates random introduction to error message
def gen_error_intro(error_msg, boring):
    '''Generates random introduction to error message.
    The function takes two arguments - the first is the error message.
    If the second one is True,
    a enterprise friendly error introduction will be provided.
    Returns a multi-line string'''

    # If the boring option is enabled, we will give them what they expect...
    if boring:
        logger.debug('Enterprise ready error intro has been selected')

        return (
            'Issues occured while the report was generated:\n\n"%s"\n\n'
            % error_msg + 'Read application log for more information')

    error_intros = [
        'Things got foobar while the status report was generated:',
        'Something always seems to break around here:',
        'Sorry mate, but things just went south with the report:',
        'It seems like the computer can\'t compute:',
        'I\'m not really sure how to say this... but here it is:']

    error_intro = error_intros[random.randrange(0, len(error_intros))]
    logger.debug('Randomized error introduction: "%s"' % str(error_intro))

    error_msg = error_intro + '\n\n"%s"' % error_msg
    return error_msg


# Generates application output
def gen_output(greeting, messages):
    '''Generates application output.
    The function takes two arguments - a dict with greeting phrases
    and a list containing data to include in the message body'''

    logger.debug(
        'Generating application output with greeting "%s" and %i message(s)'
        % (str(greeting), len(messages)))

    body = ''

    for message in messages:
        body = body + message + '\n'

    body.rstrip()

    return greeting['hi'] + '\n' + body + '\n' + greeting['bye']


# Get over-all host status
def get_host_status(session, exclude):
    '''Get over-all host status.
    The function takes two arguments - a Monitor session object
    and a exlude filter string for the host category.
    Returns a multi line string with over-all host status.'''

    logger.debug('Retrieving over-all host status')

    session.query_filter(
        '[hosts] state != 0 and acknowledged = 0 '
        'and scheduled_downtime_depth = 0' + exclude,
        ['name', 'state', 'is_flapping', 'last_state_change'])


# Main application function
def main(prog, args):
    '''Main application function. Takes two arguments -
    application name and object with runtime options'''

    # Configures application logging
    global logger
    logger = log_init(prog, args.logging, args.verbose)

    logger.debug('Provided arguments: "%s"' % str(args))

    greeting = gen_greeting(args.boring)

    session = MonitorApi(
        args.username, args.password, args.server, args.verify)

    exclude = gen_exclude_filter(args.exc_host, args.exc_host_g)

    # Creates list of messages used to generate application output
    messages = []

    try:
        messages.append(
            get_host_status(session, exclude['hosts']))

    except MonitorApi.QueryError as error_msg:
        logger.debug('Runtime error occured: "%s"' % error_msg)

        # Makes error message a list and gives error intro text
        messages = [gen_error_intro(str(error_msg), args.boring)]

        print gen_output(greeting, messages)
        exit(2)

    exit(0)


# Parses and runs main function if application is being run standalone
if __name__ == '__main__':
    args = arg_parser(prog, version, description, author, license)

    main(prog, args)
